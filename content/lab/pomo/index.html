<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
<title>Po(st)mo(dernism)doro</title>
<style>
:root {
    --light: #222;
    --light-secondary: #555;
    --dark: white;
    --dark-secondary: #ccc;
}

body {
    color: var(--light);
}

* {
    transition: background 0.2s ease;
}

body.pomo {
    background-color: #1c282f;
    color: var(--dark);
}

body.pomo.pause {
    background-color: #2c2d2e;
}

body.done {
    background-color: #ffcffc;
}

.col {
    padding-right: 30px;
}

.app {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    /*gap: 1.25rem;*/
    font-family: system-ui, sans-serif;
    margin: 0;
}

#timer {
    font-size: 3rem;
    font-variant-numeric: tabular-nums;
    margin-top: 1.25rem;
}

.modes {
    display: flex;
    gap: 1rem;
}

.controls {
    display: flex;
    gap: 0.75rem;
}

button {
    background: none;
    border: 1px solid var(--light-secondary);
    padding: 0.4rem 0.8rem;
    font-size: 1rem;
    cursor: pointer;
    color: var(--light);
}

body.pomo button {
    border-color: var(--dark-secondary);
    color: var(--dark);
}

.modes button {
    border: none;
    margin: 0;
    padding: 0;
    transition: opacity 0.3s, filter 0.3s;
}

.modes button img {
    width: auto;
    height: auto;
    min-height: 8rem;
    max-height: 15vh;
    object-fit: contain;
    display: block;
}

body.pomo .modes button {
    filter: grayscale(.6); /* looks better when in dark themes */
}

.modes button:not(.active) {
    filter: grayscale(1);
    opacity: 0.5;
}

.modes button:hover {
    opacity: 1;
    filter: grayscale(0);
}

.modes:has(button:hover) button:not(:hover) {
    opacity: 0.5;
    filter: grayscale(1);
}

/*
button.active {
    background: var(--light);
    color: var(--dark);
    border-color: var(--light);
}

body.pomo button.active {
    background: var(--dark);
    color: var(--light);
    border-color: var(--dark);
}
*/

.controls button {
    font-size: 3rem;
    border: none;
}

.controls button#reset {
    transform: translateY(-10%); /* to match vertically with play/pause button */
}

.progress {
    display: flex;
    gap: 0.5rem;
    margin-top: 1rem;
}

.dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: var(--light);
    transition: background 0.2s ease;
}

.dot.active {
    background: #fffad5; /* a little brighter & paler in day */
    box-shadow: 0 0 4px #fff7b0; /* smaller but more intense glow in day */
}

body.pomo .dot.active {
    background: #fff178; /* a little warmer at night */
    box-shadow: 0 0 10px rgb(from #fff7b0 r g b / 30%); /* larger but less intense glow at night */
}

.progress.reset-armed .dot {
    background: #bbb;
}

.progress.reset-armed .dot.active {
    background: #ff4a3a;
    box-shadow: 0 0 4px rgba(255,75,75,0.7);
}

body.pomo .progress.reset-armed .dot {
    background: #888;
}

body.pomo .progress.reset-armed .dot.active {
    background: #fb4242;
    box-shadow: 0 0 6px rgba(251,66,66,0.35);
}

.intentions {
    margin-top: 2rem;
    width: 300px;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    height: 15lh;
    overflow-y: auto; /* scrollable */
}

.intentions input {
    width: calc(300px - 1.2rem);
    padding: 0;
    font-size: 1rem;
    background: none;
    border: none;
}

.intentions input:focus {
    outline: none;
}

#intentionInput {
    padding: 0.4rem 0.6rem;
    color: var(--light-secondary);
    border-bottom: 1px solid rgb(from var(--light-secondary) r g b / 50%);
    opacity: 0.5;
}

#intentionInput.hide {
    display: none;
}

body.pomo #intentionInput {
    color: var(--dark-secondary);
    border-bottom: 1px solid rgb(from var(--dark-secondary) r g b / 50%);
}

.intentions input:focus, #intentionInput:focus {
    opacity: 1;
    color: var(--light);
    border-bottom: 1px solid var(--light);
}

body.pomo .intentions input:focus, body.pomo #intentionInput:focus {
    color: var(--dark);
    border-bottom: 1px solid var(--dark);
}

#intentionInput::placeholder {
    color: var(--light-secondary);
    opacity: 0.5;
}

body.pomo #intentionInput::placeholder {
    color: var(--dark-secondary);
}

#intentionList {
    list-style: none;
    padding: 0;
    margin: 0;
}

#intentionList li input {
    padding: 0.25rem 0.6rem;
    opacity: 0.5;
    color: var(--light-secondary);
    border-bottom: 1px solid rgb(from var(--light-secondary) r g b / 50%);
    transition: opacity 0.3s;
}

body.pomo #intentionList li input {
    color: var(--dark-secondary);
    border-bottom: 1px solid rgb(from var(--dark-secondary) r g b / 50%);
}

.intentions:not(:has(#intentionInput:focus)) #intentionList.focus li:first-child input {
    opacity: 1;
    color: var(--light);
    border-bottom: 1px solid var(--light);
}

body.pomo .intentions:not(:has(#intentionInput:focus)) #intentionList.focus li:first-child input {
    opacity: 1;
    color: var(--dark);
    border-bottom: 1px solid var(--dark);
}

#intentionList li input:hover {
    opacity: 1;
    color: var(--light);
    border-bottom: 1px solid var(--light);
}

body.pomo #intentionList li input:hover {
    color: var(--dark);
    border-bottom: 1px solid var(--dark);
}

header {
    display: none;
}
</style>

<div class="app">
    <div class="modes">
        <button data-mode="focus"><img loading="lazy" src="/assets/img/lab/pomo/focus.png"></button>
        <button data-mode="shortBreak"><img loading="lazy" src="/assets/img/lab/pomo/break.png"></button>
        <button data-mode="longBreak"><img loading="lazy" src="/assets/img/lab/pomo/rest.png"></button>
    </div>
    <div id="timer">25:00</div>
    <div class="controls">
        <button id="playpause" onclick="toggle()">&#x23F5;</button>
        <button id="reset">&#8634;</button>
    </div>
    <div class="progress">
        <span class="dot"></span>
        <span class="dot"></span>
        <span class="dot"></span>
        <span class="dot"></span>
    </div>
    <div class="intentions">
          <input type="text" id="intentionInput" placeholder="Set intention for this session..." />
          <ul id="intentionList"></ul>
    </div>

    </div>
</div>

<script>
    const DURATIONS = { focus: 25*60, shortBreak: 5*60, longBreak: 20*60 };
    let mode = 'focus'; // 'focus', 'shortBreak', 'longBreak'
    let seconds = { focus: DURATIONS.focus, shortBreak: DURATIONS.shortBreak, longBreak: DURATIONS.longBreak };
    let interval = null;
    let pomodoroCount = 0;
    let shift = false;
    let intentions = [];
    let startTime = Date.now();

    function saveState() {
        localStorage.setItem("pomodoroState", JSON.stringify({
            mode,
            seconds,
            pomodoroCount,
            intentions
            //running
        }));
    }

    function loadState() {
        const saved = localStorage.getItem("pomodoroState");
        if (!saved) return;
        const state = JSON.parse(saved);
        mode = state.mode;
        seconds = state.seconds;
        pomodoroCount = state.pomodoroCount;
        intentions = state.intentions || [];
        //running = state.running;
    }

    function updateDisplay() {
        const mins = Math.floor(seconds[mode] / 60);
        const secs = seconds[mode] % 60;
        document.getElementById("timer").textContent =
          String(mins).padStart(2, "0") + ":" +
          String(secs).padStart(2, "0");
        document.querySelectorAll(".modes button").forEach(btn => {
            btn.classList.toggle("active", btn.dataset.mode === mode);
        });
    }

    function stop() {
        clearInterval(interval);
        interval = null;
        document.getElementById('playpause').textContent = '\u23F5';
    }

    function toggle() {
        if (interval) {
            document.body.classList.remove('done');
            document.body.classList.add('pomo');
            document.body.classList.add('pause');
            stop();
        } else {
            interval = setInterval(() => {
                seconds[mode]--;
                // Chrome will fuck with the interval when the tab is not
                // focused, so we need an efficient way to catch up the time.
                // The +1 prevents this from happening too often, since it
                // doesn't matter if we're a second behind.
                // This should prevent any drift as it will correct pretty immediately.
                if (startTime + ((seconds[mode] + 1) * 1000) < Date.now()) {
                    //const mins = Math.floor(seconds[mode] / 60);
                    //const secs = seconds[mode] % 60;
                    //const disp = String(mins).padStart(2, "0") + ":" + String(secs).padStart(2, "0");
                    //console.log('starttime:', new Date(startTime).toString());
                    //console.log('seconds left:', disp);
                    //console.log('starttime + seconds:', new Date(startTime + seconds[mode]*1000).toString());
                    //console.log('now:', new Date(Date.now()).toString());
                    //console.log('delta in ms:', Date.now() - startTime - (seconds[mode] * 1000));
                    //console.log('delta in  s:', Math.floor((Date.now() - startTime - (seconds[mode] * 1000)) / 1000));
                    seconds[mode] -= Math.floor((Date.now() - startTime - (seconds[mode] * 1000)) / 1000);
                    startTime = Date.now();
                }
                if (seconds[mode] <= 0) {
                    seconds[mode] = 0;
                    finishPhase();
                }
                updateDisplay();
            }, 1000);

            document.getElementById('playpause').textContent = '\u23F8';
            document.body.classList.remove('done');
            document.body.classList.remove('pause');
            document.body.classList.add('pomo');
        }
        saveState();
    }

    function finishPhase() {
        stop();
        document.body.classList.remove('pomo');
        document.body.classList.remove('pause');
        document.body.classList.add('done');
        if (mode === "focus") {
            pomodoroCount++;
            mode = (pomodoroCount % 4 === 0) ? "longBreak" : "shortBreak";
            document.getElementById('intentionList').classList.remove('focus');
        } else {
            mode = "focus";
            document.getElementById('intentionInput').classList.remove('hide');
        }
        seconds[mode] = DURATIONS[mode];
        startTime = Date.now();
        saveState();
        updateProgress();
    }

    function updateProgress() {
        const dots = document.querySelectorAll(".dot");
        let lit = pomodoroCount % 4;
        if (pomodoroCount % 4 === 0 && pomodoroCount > 0 && seconds.longBreak > 0) lit = 4;
        /* Worth explaining how this works.
         * You're allowed to change modes whenever you want, but the lights at
         * the bottom are basically encouragement to actually follow the method
         * and work up to the long break. The lights track how close you are to
         * a long break, remind you to take it if you see all four lit up, and
         * if you're in a long break they will stay on while in the break as a
         * little visually satisfying reward to show you actually worked up to
         * it. Only once you actually take the long break will the lights
         * disappear, or if you finish another focus block. You can reset your
         * progress by shift-clicking the reset button. Of course you can also
         * just update things manually in the console.
         */
       
        dots.forEach((dot, i) => {
            dot.classList.toggle("active", i < lit);
        });
     }

    function reset() {
        clearInterval(interval);
        interval = null;
        document.getElementById('intentionInput').classList.remove('hide');
        document.getElementById('intentionList').classList.remove('focus');
        document.getElementById('playpause').textContent = '\u23F5';
        document.body.classList.remove('pomo');
        document.body.classList.remove('pause');
        document.body.classList.add('done');
        seconds[mode] = DURATIONS[mode];
        updateDisplay();
        saveState();
    }

    function renderIntentions() {
        intentionList.innerHTML = "";
        intentions.slice().reverse().forEach(text => { // newest first
            const li = document.createElement("li");
            const inp = document.createElement("input");
            inp.type = 'text';
            inp.value = text;
            inp.addEventListener('change', (e) => {
                if (e.target.value.trim() === '') {
                    intentions.splice(intentions.length-Array.from(inp.parentNode.parentNode.children).indexOf(inp.parentNode)-1, 1);
                    inp.parentNode.remove();
                } else {
                    intentions[intentions.length-Array.from(inp.parentNode.parentNode.children).indexOf(inp.parentNode)-1] = e.target.value;
                }
                saveState();
                e.target.blur();
            });
            inp.addEventListener('keydown', (e) => {
                if (e.key === "Enter") {
                    e.target.blur();
                }
            });
            li.appendChild(inp)
            //li.textContent = text;
            //li.contentEditable = true;
            intentionList.appendChild(li);
        });
    }

    function addIntention(text) {
        document.getElementById('intentionList').classList.add('focus');
        document.getElementById('intentionInput').classList.add('hide');
        if (!text.trim()) {
            //document.getElementById('intentionInput').blur(); // deselect
        } else {
            intentions.push(text.trim());
            saveState();
            renderIntentions();
            intentionInput.value = "";
        }
    }

    intentionInput.addEventListener("keydown", e => {
        if (e.key === "Enter") {
            addIntention(intentionInput.value);
        }
    });

    document.querySelectorAll(".modes button").forEach(btn => {
        btn.addEventListener("click", () => {
            stop();
            document.body.classList.remove('pomo');
            document.body.classList.remove('pause');
            document.body.classList.add('done');
            mode = btn.dataset.mode;
            if (mode === 'focus') document.getElementById('intentionInput').classList.remove('hide');
            if (mode === 'focus' && seconds.focus > 0 && seconds.focus < DURATIONS.focus) {
                document.getElementById('intentionList').classList.add('focus');
            } else {
                document.getElementById('intentionList').classList.remove('focus');
            }
            if (seconds[mode] === 0) seconds[mode] = DURATIONS[mode];
            startTime = Date.now();
            saveState();
            updateDisplay();
            updateProgress();
        });
    });

    document.addEventListener("keydown", e => {
        if (e.code === "Space" && e.target.getAttribute('type')!='text') {
            e.preventDefault();
            toggle();
        }
    });

    const resetButton = document.getElementById("reset");
    const progress = document.querySelector(".progress");

    document.addEventListener("keydown", e => {
        if (e.key === "Shift") {
            shift = true;
            if (resetButton.matches(":hover")) {
                progress.classList.add("reset-armed");
            }
        }
    });

    document.addEventListener("keyup", e => {
        if (e.key === "Shift") {
            shift = false;
            progress.classList.remove("reset-armed");
        }
    });
    
    resetButton.addEventListener("mouseenter", () => {
        if (shift) progress.classList.add("reset-armed");
    });
    
    resetButton.addEventListener("mouseleave", () => {
        progress.classList.remove("reset-armed");
    });

    resetButton.addEventListener("click", (e) => {
        if (e.shiftKey) {
            pomodoroCount = Math.floor(pomodoroCount / 4) * 4;
            saveState();
            updateProgress();
            progress.classList.remove("reset-armed");
        } else {
            reset();
        }
    });

    loadState();
    updateProgress();
    updateDisplay();
    renderIntentions();
    document.body.classList.add('done');

  </script>
</body>
</html>
